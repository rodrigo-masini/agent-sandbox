name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      debug_enabled:
        type: boolean
        description: 'Enable debug mode with tmate session'
        required: false
        default: false

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  BUILDKIT_PROGRESS: plain
  CI: true
  # Versions
  PHP_VERSION: '8.2'
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '20'
  COMPOSE_VERSION: '2.24.0'

jobs:
  # Job 1: Setup and Validation
  setup:
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
      should-deploy: ${{ steps.deployment.outputs.should-deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # For proper versioning

      - name: Generate cache key
        id: cache-key
        run: |
          echo "key=${{ runner.os }}-${{ hashFiles('**/composer.lock', '**/requirements/*.txt', '**/package-lock.json') }}" >> $GITHUB_OUTPUT

      - name: Check deployment status
        id: deployment
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" && "${{ github.event_name }}" == "push" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate configuration files
        run: |
          # Validate JSON files
          for file in $(find . -name "*.json" -not -path "./vendor/*" -not -path "./node_modules/*"); do
            python3 -m json.tool "$file" > /dev/null || { echo "Invalid JSON: $file"; exit 1; }
          done
          
          # Validate YAML files
          for file in $(find . -name "*.yml" -o -name "*.yaml" -not -path "./.git/*"); do
            python3 -c "import yaml; yaml.safe_load(open('$file'))" || { echo "Invalid YAML: $file"; exit 1; }
          done

  # Job 2: Prepare Environment
  prepare:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
          buildkitd-flags: --debug
          driver-opts: |
            image=moby/buildkit:v0.12.0
            network=host

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Fix Backend Dockerfile
        run: |
          echo "ðŸ”§ Fixing known Dockerfile issues..."
          
          # Remove json extension (built-in for PHP 8.x)
          if grep -q "docker-php-ext-install.*json" backend/docker/Dockerfile; then
            sed -i 's/\bjson\b//g' backend/docker/Dockerfile
            sed -i 's/  */ /g' backend/docker/Dockerfile
            echo "âœ… Removed json extension from Dockerfile"
          fi

      - name: Generate composer.lock
        run: |
          if [ ! -f backend/composer.lock ]; then
            echo "ðŸ“¦ Generating composer.lock..."
            docker run --rm \
              -v "$(pwd)/backend":/app \
              -w /app \
              composer:2.7 \
              update \
              --no-interaction \
              --prefer-dist \
              --prefer-stable \
              --ignore-platform-reqs \
              --no-scripts
          fi

      - name: Setup Python modules
        run: |
          echo "ðŸ Setting up Python module structure..."
          for dir in src src/app src/core src/clients src/tools src/ui src/ui/components src/ui/layouts; do
            mkdir -p "frontend/$dir"
            touch "frontend/$dir/__init__.py"
          done

      - name: Create test environment
        run: |
          cp .env.example .env
          
          # Set test values
          sed -i 's/FABRIC_API_KEY=.*/FABRIC_API_KEY=test_api_key/g' .env
          sed -i 's/FABRIC_ORG_ID=.*/FABRIC_ORG_ID=test_org/g' .env
          sed -i 's/FABRIC_PROJECT_ID=.*/FABRIC_PROJECT_ID=test_project/g' .env
          sed -i 's/AGTSDBX_API_KEY=.*/AGTSDBX_API_KEY=test_backend_key/g' .env
          sed -i 's/SECRET_KEY=.*/SECRET_KEY=test_secret_key/g' .env
          sed -i 's/JWT_SECRET=.*/JWT_SECRET=test_jwt_secret/g' .env
          sed -i 's/API_KEYS=.*/API_KEYS=test_key_1,test_key_2/g' .env
          sed -i 's/REQUIRE_AUTH=.*/REQUIRE_AUTH=false/g' .env

      - name: Upload prepared environment
        uses: actions/upload-artifact@v4
        with:
          name: prepared-env
          path: |
            .env
            backend/composer.lock
            frontend/src/**/__init__.py
          retention-days: 1

  # Job 3: Build Docker Images
  build:
    runs-on: ubuntu-latest
    needs: prepare
    strategy:
      matrix:
        service: [backend, frontend]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download prepared environment
        uses: actions/download-artifact@v4
        with:
          name: prepared-env

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build ${{ matrix.service }} image
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          file: ./${{ matrix.service }}/docker/Dockerfile
          target: development
          tags: agtsdbx-${{ matrix.service }}:test
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service }}
          load: true
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Test ${{ matrix.service }} container startup
        run: |
          echo "ðŸ§ª Testing ${{ matrix.service }} container..."
          
          if [ "${{ matrix.service }}" == "backend" ]; then
            docker run -d \
              --name test-${{ matrix.service }} \
              --env-file .env \
              -p 8000:8000 \
              agtsdbx-${{ matrix.service }}:test
              
            # Wait for health with detailed logging
            for i in {1..30}; do
              echo "Attempt $i/30..."
              
              # Check container status
              if ! docker ps | grep -q test-${{ matrix.service }}; then
                echo "âŒ Container stopped!"
                docker logs test-${{ matrix.service }}
                exit 1
              fi
              
              # Test health endpoint
              if curl -sf http://localhost:8000/health; then
                echo "âœ… Backend is healthy!"
                break
              fi
              
              if [ $i -eq 30 ]; then
                echo "âŒ Health check timeout"
                docker logs test-${{ matrix.service }}
                exit 1
              fi
              
              sleep 2
            done
          else
            # Frontend test
            docker run -d \
              --name test-${{ matrix.service }} \
              --env-file .env \
              -p 8080:8080 \
              agtsdbx-${{ matrix.service }}:test
              
            sleep 10
            docker logs test-${{ matrix.service }}
          fi
          
          docker stop test-${{ matrix.service }}
          docker rm test-${{ matrix.service }}

      - name: Save image
        run: |
          docker save agtsdbx-${{ matrix.service }}:test | gzip > ${{ matrix.service }}-image.tar.gz

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ matrix.service }}
          path: ${{ matrix.service }}-image.tar.gz
          retention-days: 1

  # Job 4: Unit Tests
  unit-tests:
    runs-on: ubuntu-latest
    needs: prepare
    strategy:
      matrix:
        include:
          - language: php
            version: '8.2'
            directory: backend
          - language: python
            version: '3.11'
            directory: frontend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download prepared environment
        uses: actions/download-artifact@v4
        with:
          name: prepared-env

      - name: Setup ${{ matrix.language }} ${{ matrix.version }}
        if: matrix.language == 'php'
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ matrix.version }}
          extensions: pdo, redis, json, mbstring, xml, curl
          coverage: xdebug

      - name: Setup ${{ matrix.language }} ${{ matrix.version }}
        if: matrix.language == 'python'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.version }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          cd ${{ matrix.directory }}
          if [ "${{ matrix.language }}" == "php" ]; then
            composer install --no-interaction --prefer-dist
          else
            pip install -r requirements/dev.txt
          fi

      - name: Run tests with coverage
        run: |
          cd ${{ matrix.directory }}
          if [ "${{ matrix.language }}" == "php" ]; then
            vendor/bin/phpunit --coverage-clover=coverage.xml --coverage-html=coverage-html
          else
            pytest tests/ --cov=src --cov-report=xml --cov-report=html:coverage-html -v
          fi

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ${{ matrix.directory }}/coverage.xml
          flags: ${{ matrix.language }}-${{ matrix.version }}
          fail_ci_if_error: false

  # Job 5: Integration Tests with Enhanced Debugging
  integration:
    runs-on: ubuntu-latest
    needs: build
    services:
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
      
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: agtsdbx
          POSTGRES_USER: agtsdbx
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker images
        uses: actions/download-artifact@v4
        with:
          pattern: docker-image-*
          merge-multiple: true

      - name: Load Docker images
        run: |
          docker load < backend-image.tar.gz
          docker load < frontend-image.tar.gz

      - name: Download prepared environment
        uses: actions/download-artifact@v4
        with:
          name: prepared-env

      - name: Create Docker network
        run: docker network create test-network

      - name: Start backend with debugging
        run: |
          echo "ðŸš€ Starting backend container..."
          
          docker run -d \
            --name agtsdbx-backend \
            --network test-network \
            --env-file .env \
            -e DATABASE_URL=postgresql://agtsdbx:test_password@postgres:5432/agtsdbx \
            -e REDIS_HOST=redis \
            -e APP_DEBUG=true \
            -e LOG_LEVEL=debug \
            -p 8000:8000 \
            agtsdbx-backend:test
          
          echo "â³ Waiting for backend to be healthy..."
          
          # Enhanced health check with debugging
          for i in {1..60}; do
            echo "Health check attempt $i/60..."
            
            # Check if container is still running
            if ! docker ps | grep -q agtsdbx-backend; then
              echo "âŒ Backend container stopped!"
              echo "Exit code: $(docker inspect agtsdbx-backend --format='{{.State.ExitCode}}')"
              echo "=== Container Logs ==="
              docker logs agtsdbx-backend
              echo "=== Container Inspect ==="
              docker inspect agtsdbx-backend | jq '.[] | {State, Config: {Env: .Config.Env}}'
              exit 1
            fi
            
            # Try health endpoint with verbose output
            if curl -v -f http://localhost:8000/health 2>&1 | tee health-check.log; then
              echo "âœ… Backend is healthy!"
              cat health-check.log | grep -E '(HTTP|{)'
              break
            fi
            
            # Show container logs periodically
            if [ $((i % 10)) -eq 0 ]; then
              echo "=== Container logs (last 20 lines) ==="
              docker logs --tail 20 agtsdbx-backend
            fi
            
            if [ $i -eq 60 ]; then
              echo "âŒ Backend health check timeout!"
              echo "=== Final container logs ==="
              docker logs agtsdbx-backend
              echo "=== Process list inside container ==="
              docker exec agtsdbx-backend ps aux || true
              echo "=== Check file system ==="
              docker exec agtsdbx-backend ls -la /app/ || true
              docker exec agtsdbx-backend ls -la /app/vendor/ || true
              docker exec agtsdbx-backend php -v || true
              exit 1
            fi
            
            sleep 2
          done

      - name: Start frontend
        run: |
          docker run -d \
            --name agtsdbx-frontend \
            --network test-network \
            --env-file .env \
            -e AGTSDBX_BASE_URL=http://agtsdbx-backend:8000 \
            -p 8080:8080 \
            agtsdbx-frontend:test
          
          sleep 20
          docker logs agtsdbx-frontend

      - name: Run API integration tests
        run: |
          echo "ðŸ§ª Running API integration tests..."
          
          # Test backend endpoints
          curl -X GET http://localhost:8000/health -f || exit 1
          
          curl -X GET http://localhost:8000/api/v1/system/info \
            -H "Authorization: ApiKey test_key_1" \
            -H "Content-Type: application/json" \
            -f || echo "System info endpoint requires auth"
          
          # Test command execution
          curl -X POST http://localhost:8000/api/v1/exec \
            -H "Authorization: ApiKey test_key_1" \
            -H "Content-Type: application/json" \
            -d '{"command": "echo test"}' \
            -f || echo "Command execution test"

      - name: Run E2E tests
        run: |
          # Install test dependencies
          pip install pytest pytest-asyncio httpx
          
          # Run E2E tests
          cd frontend
          python -m pytest tests/test_e2e.py -v

      - name: Debug information on failure
        if: failure()
        run: |
          echo "=== Docker processes ==="
          docker ps -a
          
          echo "=== Backend logs ==="
          docker logs agtsdbx-backend || true
          
          echo "=== Frontend logs ==="
          docker logs agtsdbx-frontend || true
          
          echo "=== Network information ==="
          docker network inspect test-network || true

      - name: Setup tmate session for debugging
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.debug_enabled && failure() }}
        uses: mxschmitt/action-tmate@v3
        with:
          limit-access-to-actor: true

  # Job 6: Security Scanning
  security:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: auto

  # Job 7: Performance Testing
  performance:
    runs-on: ubuntu-latest
    needs: integration
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download prepared environment
        uses: actions/download-artifact@v4
        with:
          name: prepared-env

      - name: Start services with docker-compose
        run: |
          docker compose up -d
          sleep 30

      - name: Run performance tests
        run: |
          # Install k6
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6
          
          # Run performance test
          cat > performance-test.js << 'EOF'
          import http from 'k6/http';
          import { check, sleep } from 'k6';
          
          export let options = {
            stages: [
              { duration: '30s', target: 10 },
              { duration: '1m', target: 20 },
              { duration: '30s', target: 0 },
            ],
            thresholds: {
              http_req_duration: ['p(95)<500'],
              http_req_failed: ['rate<0.1'],
            },
          };
          
          export default function() {
            let response = http.get('http://localhost:8000/health');
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response time < 500ms': (r) => r.timings.duration < 500,
            });
            sleep(1);
          }
          EOF
          
          k6 run performance-test.js

      - name: Store performance results
        uses: benchmark-action/github-action-benchmark@v1
        with:
          tool: 'customBiggerIsBetter'
          output-file-path: performance-results.json
          github-token: ${{ secrets.GITHUB_TOKEN }}
          auto-push: true

  # Job 8: Notification
  notify:
    runs-on: ubuntu-latest
    needs: [setup, prepare, build, unit-tests, integration, security]
    if: always()
    steps:
      - name: Create summary
        run: |
          echo "# ðŸ“Š CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Setup | ${{ needs.setup.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Prepare | ${{ needs.prepare.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | ${{ needs.unit-tests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration | ${{ needs.integration.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Security | ${{ needs.security.result }} |" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

      - name: Notify on failure
        if: contains(needs.*.result, 'failure')
        uses: actions/github-script@v7
        with:
          script: |
            const jobs = {
              setup: '${{ needs.setup.result }}',
              prepare: '${{ needs.prepare.result }}',
              build: '${{ needs.build.result }}',
              'unit-tests': '${{ needs.unit-tests.result }}',
              integration: '${{ needs.integration.result }}',
              security: '${{ needs.security.result }}'
            };
            
            const failedJobs = Object.entries(jobs)
              .filter(([_, status]) => status === 'failure')
              .map(([job, _]) => job);
            
            if (failedJobs.length > 0) {
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `ðŸš¨ CI Pipeline Failed: ${failedJobs.join(', ')}`,
                body: `## Pipeline Failure Report
                
                **Failed Jobs:** ${failedJobs.join(', ')}
                **Workflow Run:** [View Details](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
                **Commit:** ${context.sha}
                **Actor:** @${context.actor}
                
                ### Job Results
                ${Object.entries(jobs).map(([job, status]) => `- ${job}: ${status}`).join('\n')}
                
                Please investigate and fix the issues.`,
                labels: ['ci-failure', 'bug', 'high-priority']
              });
              
              console.log(`Created issue #${issue.data.number}`);
            }